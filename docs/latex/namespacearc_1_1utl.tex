\hypertarget{namespacearc_1_1utl}{}\section{arc\+:\+:utl Namespace Reference}
\label{namespacearc_1_1utl}\index{arc\+::utl@{arc\+::utl}}


utility namespace  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename C , typename T  = typename C\+::value\+\_\+type, typename I  = typename C\+::iterator, typename F $>$ }\\void \mbox{\hyperlink{namespacearc_1_1utl_a7e7db05c1cbc593d3bf9361621f763f3}{apply}} (C \&cont\+\_\+, F func\+\_\+) noexcept
\item 
{\footnotesize template$<$typename C , typename T  = typename C\+::value\+\_\+type, typename I  = typename C\+::cont\+\_\+iterator, typename F $>$ }\\void \mbox{\hyperlink{namespacearc_1_1utl_ae56f75d104c7bd4bd9abf350e349a694}{apply}} (const C \&cont\+\_\+, F func\+\_\+) noexcept
\item 
{\footnotesize template$<$typename C , typename T  = typename C\+::value\+\_\+type, typename I  = typename C\+::iterator, typename F $>$ }\\void \mbox{\hyperlink{namespacearc_1_1utl_a77de5138bbfff1ea74f34f3018361186}{apply\+\_\+with\+\_\+index}} (C \&cont\+\_\+, F func\+\_\+) noexcept
\item 
{\footnotesize template$<$typename C , typename T  = typename C\+::value\+\_\+type, typename I  = typename C\+::cont\+\_\+iterator, typename F $>$ }\\void \mbox{\hyperlink{namespacearc_1_1utl_a50e140f40e5a25a5fe253b94e6ab3403}{apply\+\_\+with\+\_\+index}} (const C \&cont\+\_\+, F func\+\_\+) noexcept
\item 
{\footnotesize template$<$typename A0 , typename A1 , typename F $>$ }\\void \mbox{\hyperlink{namespacearc_1_1utl_a77c34280ea834583a0a0563e2bdc549c}{apply}} (std\+::pair$<$ A0, A1 $>$ \&pair\+\_\+, F func\+\_\+)
\item 
{\footnotesize template$<$typename A0 , typename A1 , typename F $>$ }\\void \mbox{\hyperlink{namespacearc_1_1utl_a887b8885b94d550a15de9eef1a70fd0b}{apply}} (const std\+::pair$<$ A0, A1 $>$ \&pair\+\_\+, F func\+\_\+)
\item 
{\footnotesize template$<$typename A0 , typename A1 , typename F $>$ }\\void \mbox{\hyperlink{namespacearc_1_1utl_a97b916dd6673b3b3c190b15af1719b0a}{apply\+\_\+with\+\_\+index}} (std\+::pair$<$ A0, A1 $>$ \&pair\+\_\+, F func\+\_\+)
\item 
{\footnotesize template$<$typename A0 , typename A1 , typename F $>$ }\\void \mbox{\hyperlink{namespacearc_1_1utl_ad77a0481ab72232b49349532b96f80fc}{apply\+\_\+with\+\_\+index}} (const std\+::pair$<$ A0, A1 $>$ \&pair\+\_\+, F func\+\_\+)
\item 
{\footnotesize template$<$typename... A, typename F , size\+\_\+t... I$>$ }\\void \mbox{\hyperlink{namespacearc_1_1utl_a5421e6de5c0a785ee70d9546d6ef0c41}{apply\+\_\+to\+\_\+each}} (std\+::tuple$<$ A... $>$ \&tuple\+\_\+, F func\+\_\+, std\+::index\+\_\+sequence$<$ I... $>$)
\item 
{\footnotesize template$<$typename... A, typename F $>$ }\\void \mbox{\hyperlink{namespacearc_1_1utl_af64bed0e9e6ac7220d393a1bb62f4bff}{apply}} (std\+::tuple$<$ A... $>$ \&tuple\+\_\+, F func\+\_\+)
\item 
{\footnotesize template$<$typename... A, typename F , size\+\_\+t... I$>$ }\\void \mbox{\hyperlink{namespacearc_1_1utl_acf59dac8c2f5eea5a6aa9875db3b07f8}{apply\+\_\+to\+\_\+each}} (const std\+::tuple$<$ A... $>$ \&tuple\+\_\+, F func\+\_\+, std\+::index\+\_\+sequence$<$ I... $>$)
\item 
{\footnotesize template$<$typename... A, typename F $>$ }\\void \mbox{\hyperlink{namespacearc_1_1utl_a6dadc719c6540032592f36b5c14cae27}{apply}} (const std\+::tuple$<$ A... $>$ \&tuple\+\_\+, F func\+\_\+)
\item 
{\footnotesize template$<$typename... A, typename F , size\+\_\+t... I$>$ }\\void \mbox{\hyperlink{namespacearc_1_1utl_a0bc38a64f17e53212169cae0a6eb23bb}{apply\+\_\+to\+\_\+each\+\_\+with\+\_\+index}} (std\+::tuple$<$ A... $>$ \&tuple\+\_\+, F func\+\_\+, std\+::index\+\_\+sequence$<$ I... $>$)
\item 
{\footnotesize template$<$typename... A, typename F $>$ }\\void \mbox{\hyperlink{namespacearc_1_1utl_a2658c84859917c434ff3a7f667b21eca}{apply\+\_\+with\+\_\+index}} (std\+::tuple$<$ A... $>$ \&tuple\+\_\+, F func\+\_\+)
\item 
{\footnotesize template$<$typename... A, typename F , size\+\_\+t... I$>$ }\\void \mbox{\hyperlink{namespacearc_1_1utl_a6330262543d471ad23a1a70ea3a47b53}{apply\+\_\+to\+\_\+each\+\_\+with\+\_\+index}} (const std\+::tuple$<$ A... $>$ \&tuple\+\_\+, F func\+\_\+, std\+::index\+\_\+sequence$<$ I... $>$)
\item 
{\footnotesize template$<$typename... A, typename F $>$ }\\void \mbox{\hyperlink{namespacearc_1_1utl_ae57e12a4fd6beeb3a1a40bfd461c3a87}{apply\+\_\+with\+\_\+index}} (const std\+::tuple$<$ A... $>$ \&tuple\+\_\+, F func\+\_\+)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
utility namespace 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespacearc_1_1utl_a7e7db05c1cbc593d3bf9361621f763f3}\label{namespacearc_1_1utl_a7e7db05c1cbc593d3bf9361621f763f3}} 
\index{arc\+::utl@{arc\+::utl}!apply@{apply}}
\index{apply@{apply}!arc\+::utl@{arc\+::utl}}
\subsubsection{\texorpdfstring{apply()}{apply()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily template$<$typename C , typename T  = typename C\+::value\+\_\+type, typename I  = typename C\+::iterator, typename F $>$ \\
void arc\+::utl\+::apply (\begin{DoxyParamCaption}\item[{C \&}]{cont\+\_\+,  }\item[{F}]{func\+\_\+ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Apply a given functor to each element of a container.


\begin{DoxyTemplParams}{Template Parameters}
{\em C} & Type of container. \\
\hline
{\em T} & Type stored by C. \\
\hline
{\em I} & Type of const iterator of C. \\
\hline
{\em F} & Type of functor to be applied.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em cont\+\_\+} & Container to be applied to. \\
\hline
{\em func\+\_\+} & Functor to be applied. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacearc_1_1utl_a77c34280ea834583a0a0563e2bdc549c}\label{namespacearc_1_1utl_a77c34280ea834583a0a0563e2bdc549c}} 
\index{arc\+::utl@{arc\+::utl}!apply@{apply}}
\index{apply@{apply}!arc\+::utl@{arc\+::utl}}
\subsubsection{\texorpdfstring{apply()}{apply()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily template$<$typename A0 , typename A1 , typename F $>$ \\
void arc\+::utl\+::apply (\begin{DoxyParamCaption}\item[{std\+::pair$<$ A0, A1 $>$ \&}]{pair\+\_\+,  }\item[{F}]{func\+\_\+ }\end{DoxyParamCaption})}

Call a functor on each element of a pair.


\begin{DoxyTemplParams}{Template Parameters}
{\em A0} & First type stored by the pair. \\
\hline
{\em A1} & Second type stored by the pair. \\
\hline
{\em F} & Type of functor to be applied.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em pair\+\_\+} & Pair to be applied to. \\
\hline
{\em func\+\_\+} & Functor to be applied. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacearc_1_1utl_ae56f75d104c7bd4bd9abf350e349a694}\label{namespacearc_1_1utl_ae56f75d104c7bd4bd9abf350e349a694}} 
\index{arc\+::utl@{arc\+::utl}!apply@{apply}}
\index{apply@{apply}!arc\+::utl@{arc\+::utl}}
\subsubsection{\texorpdfstring{apply()}{apply()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily template$<$typename C , typename T  = typename C\+::value\+\_\+type, typename I  = typename C\+::cont\+\_\+iterator, typename F $>$ \\
void arc\+::utl\+::apply (\begin{DoxyParamCaption}\item[{const C \&}]{cont\+\_\+,  }\item[{F}]{func\+\_\+ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Apply a given functor to each element of a const container.


\begin{DoxyTemplParams}{Template Parameters}
{\em C} & Type of container. \\
\hline
{\em T} & Type stored by C. \\
\hline
{\em I} & Type of const iterator of C. \\
\hline
{\em F} & Type of functor to be applied.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em cont\+\_\+} & Container to be applied to. \\
\hline
{\em func\+\_\+} & Functor to be applied. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacearc_1_1utl_a887b8885b94d550a15de9eef1a70fd0b}\label{namespacearc_1_1utl_a887b8885b94d550a15de9eef1a70fd0b}} 
\index{arc\+::utl@{arc\+::utl}!apply@{apply}}
\index{apply@{apply}!arc\+::utl@{arc\+::utl}}
\subsubsection{\texorpdfstring{apply()}{apply()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily template$<$typename A0 , typename A1 , typename F $>$ \\
void arc\+::utl\+::apply (\begin{DoxyParamCaption}\item[{const std\+::pair$<$ A0, A1 $>$ \&}]{pair\+\_\+,  }\item[{F}]{func\+\_\+ }\end{DoxyParamCaption})}

Call a functor on each element of a const pair.


\begin{DoxyTemplParams}{Template Parameters}
{\em A0} & First type stored by the pair. \\
\hline
{\em A1} & Second type stored by the pair. \\
\hline
{\em F} & Type of functor to be applied.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em pair\+\_\+} & Pair to be applied to. \\
\hline
{\em func\+\_\+} & Functor to be applied. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacearc_1_1utl_af64bed0e9e6ac7220d393a1bb62f4bff}\label{namespacearc_1_1utl_af64bed0e9e6ac7220d393a1bb62f4bff}} 
\index{arc\+::utl@{arc\+::utl}!apply@{apply}}
\index{apply@{apply}!arc\+::utl@{arc\+::utl}}
\subsubsection{\texorpdfstring{apply()}{apply()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily template$<$typename... A, typename F $>$ \\
void arc\+::utl\+::apply (\begin{DoxyParamCaption}\item[{std\+::tuple$<$ A... $>$ \&}]{tuple\+\_\+,  }\item[{F}]{func\+\_\+ }\end{DoxyParamCaption})}

Apply a given functor to each element of a tuple.


\begin{DoxyTemplParams}{Template Parameters}
{\em A} & Types stored by the tuple. \\
\hline
{\em F} & Type of functor to be applied.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em tuple\+\_\+} & Tuple to be applied to. \\
\hline
{\em func\+\_\+} & Functor to be applied. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=308pt]{namespacearc_1_1utl_af64bed0e9e6ac7220d393a1bb62f4bff_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacearc_1_1utl_a6dadc719c6540032592f36b5c14cae27}\label{namespacearc_1_1utl_a6dadc719c6540032592f36b5c14cae27}} 
\index{arc\+::utl@{arc\+::utl}!apply@{apply}}
\index{apply@{apply}!arc\+::utl@{arc\+::utl}}
\subsubsection{\texorpdfstring{apply()}{apply()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily template$<$typename... A, typename F $>$ \\
void arc\+::utl\+::apply (\begin{DoxyParamCaption}\item[{const std\+::tuple$<$ A... $>$ \&}]{tuple\+\_\+,  }\item[{F}]{func\+\_\+ }\end{DoxyParamCaption})}

Apply a given functor to each element of a const tuple.


\begin{DoxyTemplParams}{Template Parameters}
{\em A} & Types stored by the tuple. \\
\hline
{\em F} & Type of functor to be applied.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em tuple\+\_\+} & Tuple to be applied to. \\
\hline
{\em func\+\_\+} & Functor to be applied. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=308pt]{namespacearc_1_1utl_a6dadc719c6540032592f36b5c14cae27_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacearc_1_1utl_a5421e6de5c0a785ee70d9546d6ef0c41}\label{namespacearc_1_1utl_a5421e6de5c0a785ee70d9546d6ef0c41}} 
\index{arc\+::utl@{arc\+::utl}!apply\+\_\+to\+\_\+each@{apply\+\_\+to\+\_\+each}}
\index{apply\+\_\+to\+\_\+each@{apply\+\_\+to\+\_\+each}!arc\+::utl@{arc\+::utl}}
\subsubsection{\texorpdfstring{apply\+\_\+to\+\_\+each()}{apply\_to\_each()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename... A, typename F , size\+\_\+t... I$>$ \\
void arc\+::utl\+::apply\+\_\+to\+\_\+each (\begin{DoxyParamCaption}\item[{std\+::tuple$<$ A... $>$ \&}]{tuple\+\_\+,  }\item[{F}]{func\+\_\+,  }\item[{std\+::index\+\_\+sequence$<$ I... $>$}]{ }\end{DoxyParamCaption})}

Apply helper function. Call a functor on each element of a const tuple.


\begin{DoxyTemplParams}{Template Parameters}
{\em A} & Types stored by the tuple. \\
\hline
{\em F} & Type of functor to be applied. \\
\hline
{\em I} & Indices of the tuple.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em tuple\+\_\+} & Tuple to be applied to. \\
\hline
{\em func\+\_\+} & Functor to be applied. \\
\hline
\end{DoxyParams}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=308pt]{namespacearc_1_1utl_a5421e6de5c0a785ee70d9546d6ef0c41_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacearc_1_1utl_acf59dac8c2f5eea5a6aa9875db3b07f8}\label{namespacearc_1_1utl_acf59dac8c2f5eea5a6aa9875db3b07f8}} 
\index{arc\+::utl@{arc\+::utl}!apply\+\_\+to\+\_\+each@{apply\+\_\+to\+\_\+each}}
\index{apply\+\_\+to\+\_\+each@{apply\+\_\+to\+\_\+each}!arc\+::utl@{arc\+::utl}}
\subsubsection{\texorpdfstring{apply\+\_\+to\+\_\+each()}{apply\_to\_each()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename... A, typename F , size\+\_\+t... I$>$ \\
void arc\+::utl\+::apply\+\_\+to\+\_\+each (\begin{DoxyParamCaption}\item[{const std\+::tuple$<$ A... $>$ \&}]{tuple\+\_\+,  }\item[{F}]{func\+\_\+,  }\item[{std\+::index\+\_\+sequence$<$ I... $>$}]{ }\end{DoxyParamCaption})}

Apply helper function. Call a functor on each element of a tuple.


\begin{DoxyTemplParams}{Template Parameters}
{\em A} & Types stored by the tuple. \\
\hline
{\em F} & Type of functor to be applied. \\
\hline
{\em I} & Indices of the tuple.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em tuple\+\_\+} & Tuple to be applied to. \\
\hline
{\em func\+\_\+} & Functor to be applied. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacearc_1_1utl_a0bc38a64f17e53212169cae0a6eb23bb}\label{namespacearc_1_1utl_a0bc38a64f17e53212169cae0a6eb23bb}} 
\index{arc\+::utl@{arc\+::utl}!apply\+\_\+to\+\_\+each\+\_\+with\+\_\+index@{apply\+\_\+to\+\_\+each\+\_\+with\+\_\+index}}
\index{apply\+\_\+to\+\_\+each\+\_\+with\+\_\+index@{apply\+\_\+to\+\_\+each\+\_\+with\+\_\+index}!arc\+::utl@{arc\+::utl}}
\subsubsection{\texorpdfstring{apply\+\_\+to\+\_\+each\+\_\+with\+\_\+index()}{apply\_to\_each\_with\_index()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename... A, typename F , size\+\_\+t... I$>$ \\
void arc\+::utl\+::apply\+\_\+to\+\_\+each\+\_\+with\+\_\+index (\begin{DoxyParamCaption}\item[{std\+::tuple$<$ A... $>$ \&}]{tuple\+\_\+,  }\item[{F}]{func\+\_\+,  }\item[{std\+::index\+\_\+sequence$<$ I... $>$}]{seq\+\_\+ }\end{DoxyParamCaption})}

Apply with index helper function. Call a functor on each element of a tuple. Provide the current tuple index and the total number of tuple types.


\begin{DoxyTemplParams}{Template Parameters}
{\em A} & Types stored by the tuple. \\
\hline
{\em F} & Type of functor to be applied. \\
\hline
{\em I} & Indices of the tuple.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em tuple\+\_\+} & Tuple to be applied to. \\
\hline
{\em func\+\_\+} & Functor to be applied. \\
\hline
{\em seq\+\_\+} & Sequence of tuple indices. \\
\hline
\end{DoxyParams}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=311pt]{namespacearc_1_1utl_a0bc38a64f17e53212169cae0a6eb23bb_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacearc_1_1utl_a6330262543d471ad23a1a70ea3a47b53}\label{namespacearc_1_1utl_a6330262543d471ad23a1a70ea3a47b53}} 
\index{arc\+::utl@{arc\+::utl}!apply\+\_\+to\+\_\+each\+\_\+with\+\_\+index@{apply\+\_\+to\+\_\+each\+\_\+with\+\_\+index}}
\index{apply\+\_\+to\+\_\+each\+\_\+with\+\_\+index@{apply\+\_\+to\+\_\+each\+\_\+with\+\_\+index}!arc\+::utl@{arc\+::utl}}
\subsubsection{\texorpdfstring{apply\+\_\+to\+\_\+each\+\_\+with\+\_\+index()}{apply\_to\_each\_with\_index()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename... A, typename F , size\+\_\+t... I$>$ \\
void arc\+::utl\+::apply\+\_\+to\+\_\+each\+\_\+with\+\_\+index (\begin{DoxyParamCaption}\item[{const std\+::tuple$<$ A... $>$ \&}]{tuple\+\_\+,  }\item[{F}]{func\+\_\+,  }\item[{std\+::index\+\_\+sequence$<$ I... $>$}]{seq\+\_\+ }\end{DoxyParamCaption})}

Apply with index helper function. Call a functor on each element of a const tuple. Provide the current tuple index and the total number of tuple types.


\begin{DoxyTemplParams}{Template Parameters}
{\em A} & Types stored by the tuple. \\
\hline
{\em F} & Type of functor to be applied. \\
\hline
{\em I} & Indices of the tuple.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em tuple\+\_\+} & Tuple to be applied to. \\
\hline
{\em func\+\_\+} & Functor to be applied. \\
\hline
{\em seq\+\_\+} & Sequence of tuple indices. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacearc_1_1utl_a97b916dd6673b3b3c190b15af1719b0a}\label{namespacearc_1_1utl_a97b916dd6673b3b3c190b15af1719b0a}} 
\index{arc\+::utl@{arc\+::utl}!apply\+\_\+with\+\_\+index@{apply\+\_\+with\+\_\+index}}
\index{apply\+\_\+with\+\_\+index@{apply\+\_\+with\+\_\+index}!arc\+::utl@{arc\+::utl}}
\subsubsection{\texorpdfstring{apply\+\_\+with\+\_\+index()}{apply\_with\_index()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily template$<$typename A0 , typename A1 , typename F $>$ \\
void arc\+::utl\+::apply\+\_\+with\+\_\+index (\begin{DoxyParamCaption}\item[{std\+::pair$<$ A0, A1 $>$ \&}]{pair\+\_\+,  }\item[{F}]{func\+\_\+ }\end{DoxyParamCaption})}

Call a functor on each element of a pair. Provide the pair index and the total number of pair types.


\begin{DoxyTemplParams}{Template Parameters}
{\em A0} & First type stored by the pair. \\
\hline
{\em A1} & Second type stored by the pair. \\
\hline
{\em F} & Type of functor to be applied.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em pair\+\_\+} & Pair to be applied to. \\
\hline
{\em func\+\_\+} & Functor to be applied. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacearc_1_1utl_a77de5138bbfff1ea74f34f3018361186}\label{namespacearc_1_1utl_a77de5138bbfff1ea74f34f3018361186}} 
\index{arc\+::utl@{arc\+::utl}!apply\+\_\+with\+\_\+index@{apply\+\_\+with\+\_\+index}}
\index{apply\+\_\+with\+\_\+index@{apply\+\_\+with\+\_\+index}!arc\+::utl@{arc\+::utl}}
\subsubsection{\texorpdfstring{apply\+\_\+with\+\_\+index()}{apply\_with\_index()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily template$<$typename C , typename T  = typename C\+::value\+\_\+type, typename I  = typename C\+::iterator, typename F $>$ \\
void arc\+::utl\+::apply\+\_\+with\+\_\+index (\begin{DoxyParamCaption}\item[{C \&}]{cont\+\_\+,  }\item[{F}]{func\+\_\+ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Apply a given functor to each element of a container. Provide the current element index and the total number of elements.


\begin{DoxyTemplParams}{Template Parameters}
{\em C} & Type of container. \\
\hline
{\em T} & Type stored by C. \\
\hline
{\em I} & Type of const iterator of C. \\
\hline
{\em F} & Type of functor to be applied.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em cont\+\_\+} & Container to be applied to. \\
\hline
{\em func\+\_\+} & Functor to be applied. \\
\hline
\end{DoxyParams}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=305pt]{namespacearc_1_1utl_a77de5138bbfff1ea74f34f3018361186_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacearc_1_1utl_a50e140f40e5a25a5fe253b94e6ab3403}\label{namespacearc_1_1utl_a50e140f40e5a25a5fe253b94e6ab3403}} 
\index{arc\+::utl@{arc\+::utl}!apply\+\_\+with\+\_\+index@{apply\+\_\+with\+\_\+index}}
\index{apply\+\_\+with\+\_\+index@{apply\+\_\+with\+\_\+index}!arc\+::utl@{arc\+::utl}}
\subsubsection{\texorpdfstring{apply\+\_\+with\+\_\+index()}{apply\_with\_index()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily template$<$typename C , typename T  = typename C\+::value\+\_\+type, typename I  = typename C\+::cont\+\_\+iterator, typename F $>$ \\
void arc\+::utl\+::apply\+\_\+with\+\_\+index (\begin{DoxyParamCaption}\item[{const C \&}]{cont\+\_\+,  }\item[{F}]{func\+\_\+ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}

Apply a given functor to each element of a const container. Provide the current element index and the total number of elements.


\begin{DoxyTemplParams}{Template Parameters}
{\em C} & Type of container. \\
\hline
{\em T} & Type stored by C. \\
\hline
{\em I} & Type of const iterator of C. \\
\hline
{\em F} & Type of functor to be applied.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em cont\+\_\+} & Container to be applied to. \\
\hline
{\em func\+\_\+} & Functor to be applied. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacearc_1_1utl_ad77a0481ab72232b49349532b96f80fc}\label{namespacearc_1_1utl_ad77a0481ab72232b49349532b96f80fc}} 
\index{arc\+::utl@{arc\+::utl}!apply\+\_\+with\+\_\+index@{apply\+\_\+with\+\_\+index}}
\index{apply\+\_\+with\+\_\+index@{apply\+\_\+with\+\_\+index}!arc\+::utl@{arc\+::utl}}
\subsubsection{\texorpdfstring{apply\+\_\+with\+\_\+index()}{apply\_with\_index()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily template$<$typename A0 , typename A1 , typename F $>$ \\
void arc\+::utl\+::apply\+\_\+with\+\_\+index (\begin{DoxyParamCaption}\item[{const std\+::pair$<$ A0, A1 $>$ \&}]{pair\+\_\+,  }\item[{F}]{func\+\_\+ }\end{DoxyParamCaption})}

Call a functor on each element of a const pair. Provide the pair index and the total number of pair types.


\begin{DoxyTemplParams}{Template Parameters}
{\em A0} & First type stored by the pair. \\
\hline
{\em A1} & Second type stored by the pair. \\
\hline
{\em F} & Type of functor to be applied.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em pair\+\_\+} & Pair to be applied to. \\
\hline
{\em func\+\_\+} & Functor to be applied. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacearc_1_1utl_a2658c84859917c434ff3a7f667b21eca}\label{namespacearc_1_1utl_a2658c84859917c434ff3a7f667b21eca}} 
\index{arc\+::utl@{arc\+::utl}!apply\+\_\+with\+\_\+index@{apply\+\_\+with\+\_\+index}}
\index{apply\+\_\+with\+\_\+index@{apply\+\_\+with\+\_\+index}!arc\+::utl@{arc\+::utl}}
\subsubsection{\texorpdfstring{apply\+\_\+with\+\_\+index()}{apply\_with\_index()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily template$<$typename... A, typename F $>$ \\
void arc\+::utl\+::apply\+\_\+with\+\_\+index (\begin{DoxyParamCaption}\item[{std\+::tuple$<$ A... $>$ \&}]{tuple\+\_\+,  }\item[{F}]{func\+\_\+ }\end{DoxyParamCaption})}

Apply a given functor to each element of a tuple. Current tuple index and the total number of tuple types are provided.


\begin{DoxyTemplParams}{Template Parameters}
{\em A} & Types stored by the tuple. \\
\hline
{\em F} & Type of functor to be applied.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em tuple\+\_\+} & Tuple to be applied to. \\
\hline
{\em func\+\_\+} & Functor to be applied. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=311pt]{namespacearc_1_1utl_a2658c84859917c434ff3a7f667b21eca_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{namespacearc_1_1utl_ae57e12a4fd6beeb3a1a40bfd461c3a87}\label{namespacearc_1_1utl_ae57e12a4fd6beeb3a1a40bfd461c3a87}} 
\index{arc\+::utl@{arc\+::utl}!apply\+\_\+with\+\_\+index@{apply\+\_\+with\+\_\+index}}
\index{apply\+\_\+with\+\_\+index@{apply\+\_\+with\+\_\+index}!arc\+::utl@{arc\+::utl}}
\subsubsection{\texorpdfstring{apply\+\_\+with\+\_\+index()}{apply\_with\_index()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily template$<$typename... A, typename F $>$ \\
void arc\+::utl\+::apply\+\_\+with\+\_\+index (\begin{DoxyParamCaption}\item[{const std\+::tuple$<$ A... $>$ \&}]{tuple\+\_\+,  }\item[{F}]{func\+\_\+ }\end{DoxyParamCaption})}

Apply a given functor to each element of a const tuple. Current tuple index and the total number of tuple types are provided.


\begin{DoxyTemplParams}{Template Parameters}
{\em A} & Types stored by the tuple. \\
\hline
{\em F} & Type of functor to be applied.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em tuple\+\_\+} & Tuple to be applied to. \\
\hline
{\em func\+\_\+} & Functor to be applied. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=311pt]{namespacearc_1_1utl_ae57e12a4fd6beeb3a1a40bfd461c3a87_cgraph}
\end{center}
\end{figure}
